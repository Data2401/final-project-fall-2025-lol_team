---
title: "LOL_Dataset_Project"
author: "Tamana Yaqoubi, Veronica Alviso"
date: "2025-11-04"
output: html_document
runtime: shiny
---

## About the dataset 
https://www.kaggle.com/datasets/nathansmallcalder/lol-match-history-and-summoner-data-80k-matches

- The data comes from League of legends (European Region). 
- Shows team analysis and per player analysis providing insight stats in KDA, items, characters "champions', winning, etc 
- The dataset comes from Kaggle.com
##Introduction 
This dataset provides comprehensive match and player information from League of Legends, one of the worldâ€™s most popular multiplayer online battle arena (MOBA) games. It features data from 35,000 matches and over 78,000 player records, covering various in-game aspects such as champion choices, performance metrics, match results, and other gameplay statistics. This dataset consist of 7 tables: MatchStatsTbl, TeamMatchStatsTbl, MatchTbl, RankTble, ChampionTbl, ItemTbl, SummonerTbl, and SummonerMatchTbl. 



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidyr)
library(dplyr)
library(ggplot2)
library(kableExtra)
library(gridExtra)
library(plotly)
library(shiny)
library(here)
source("R_Data_Prep.R")
#data_dir <- here::here(".")

```

## Read csv files
```{r, echo = FALSE}
'
championTbl <- read_tbl("ChampionTbl")
itemTbl<- read_tbl("ItemTbl")
matchStatsTbl <- read_tbl("MatchStatsTbl")
matchTbl <- read_tbl("MatchTbl")
RankTbl <- read_tbl("RankTbl")
SummonerMatchTbl <- read_tbl("SummonerMatchTbl")
TeamMatchTbl <- read_tbl("TeamMatchTbl")
'
```
---

## View Original datasets
```{r}
head(championTbl) %>% knitr::kable()
head(itemTbl) %>% knitr::kable()
head(matchStatsTbl) %>% knitr::kable()
head(matchTbl) %>% knitr::kable()
head(RankTbl, n = 11) %>% knitr::kable()
head(SummonerMatchTbl) %>% knitr::kable()
head(TeamMatchTbl) %>% knitr::kable()

```

---

## Modified Tables

What we did is join most of our data sets to have a more efficient data structure. The following data sets were created:
 - match_rank_tbl : This table displays every match in EU region with the following information: Queue type, Rank, Game duration. 
 - MSI_Tbl : This data set will display the players detailed match stats which include kills for both enemy champions and monsters affiliated and include item purchase and summoner spells.
 - SMR_Tbl : This data set displays the players detailed 


```{r, echo =FALSE}
head(match_rank_tbl)
head(TMR_Tble)
head(SMR_Tbl)
```

---

## Joining SMR table and MSI table -TY
```{r}
#SMRI_tbl <- full_join(SMR_Tbl, MSI_Tbl, by = join_by(SummonerMatchId==SummonerMatchFk))
#SMRI_tbl 
#Needs further filtering 
```

---

## Tamana MSI_tbl and Match_rank_tbl dplyr and plot functions

#MSI_Tbl

1. How many SummonerMatchFk play more than one lane


```{r, echo=FALSE}
MSI_Tbl %>%
  group_by(SummonerMatchFk)%>%
  summarise(num_lanes = n_distinct(Lane))%>% #count the unique lanes
  filter(num_lanes > 1)%>%
  summarise(total_players = n())

```


2. Find the Mean, Median, Max, and Min for the following:
- minions killed
- TurretDmg
- DmgTaken
- DmgDealt
- totalGold.


Mean median min and max of minions killed: 
```{r, echo = F}
# mean, median, min, and max of Minions Killed
MSI_Tbl%>%
  summarise(avg_minionsKilled = mean(MinionsKilled, na.rm = T),
            median_minionsKilled = median(MinionsKilled, na.rm = T),
            min_minionsKilled = min(MinionsKilled, na.rm = T),
            max_minionsKilled = max(MinionsKilled, na.rm = T))
```

Mean median min and max of Turret Damage killed:
```{r, echo=FALSE}

# mean, median, min, and max of TurretDmg
MSI_Tbl%>%
  summarise(avg_TurretDmgDealt = mean(TurretDmgDealt, na.rm = T),
            median_TurretDmgDealt = median(TurretDmgDealt, na.rm = T),
            min_TurretDmgDealt = min(TurretDmgDealt, na.rm = T), 
            max_TurretDmgDealt = max(TurretDmgDealt, na.rm = T))
```

Mean median min and max of Damage Taken killed:
```{r, echo=FALSE}
# mean, median, min, and max of DmgTaken
MSI_Tbl%>%
  summarise(avg_DmgTaken = mean(DmgTaken, na.rm = T),
            median_DmgTaken = median(DmgTaken, na.rm = T), 
            min_DmgTaken = min(DmgTaken, na.rm = T),
            max_DmgTaken = max(DmgTaken, na.rm = T))
```

Mean median min and max of Damage Dealt killed:
```{r, echo=FALSE}
# mean, median, min, and max of DmgDealt
MSI_Tbl%>%
  summarise(avg_DmgDealt = mean(DmgDealt, na.rm = T),
            median_DmgDealt = median(DmgDealt, na.rm = T), 
            min_DmgDealt = min(DmgDealt, na.rm = T),
            max_DmgDealt = max(DmgDealt, na.rm = T))
```

Mean median min and max of total gold killed:
```{r,echo=FALSE}
# mean, median, min, and max of totalGold
MSI_Tbl%>%
  summarise(avg_TotalGold = mean(TotalGold, na.rm = T),
            median_TotalGold = median(TotalGold, na.rm = T), 
            min_TotalGold = min(TotalGold, na.rm = T),
            max_TotalGold = max(TotalGold, na.rm = T))
```

---

3. Create new column (boolean) for indicating win or lose. Filter to win and lose only and create a ggplots.

```{r, echo=FALSE}
MSI_Tbl%>%
  mutate(won = Win != 0)%>%
  drop_na(won)%>% 
  ggplot(aes(x=won, fill=won)) + 
  geom_bar() +
  labs(title = "Win vs. Lose",
       x = "results",
       y = "count")
```


4. MSI_tbl (ask professor) Items, filter remove NAs, count total items, most popular items, least popular items. Median qne mean items a player holds. 


```{r}
#Lost and confused about this part, will have to ask the professor 
MSI_Tbl%>%
  drop_na(item1, item2, item3, item4, item5, item6)
```
---

5. Line plot game duration as the Y value and Queue type as the X value, filter based on RankName.


```{r}
match_rank_tbl %>%
  group_by(RankName)%>%
  summarise(Duration= n())

ggplot(match_rank_tbl, aes(color= QueueType,x = GameDuration)) + 
  geom_density() + 
  labs(title = "Game Duration",
  x = "Queue Type",
  y = "Time")
```


6. Plot game duration density 


```{r}
ggplot(match_rank_tbl, aes(x=GameDuration, fill = QueueType)) +
  geom_density() +
  labs(title = "Game Duration") + 
  facet_wrap(~QueueType)
```
---

# Created a new column called SecondLane 
```{r, echo=FALSE}
MSI_Tbl %>% 
   group_by(SummonerMatchFk) %>% 
  filter(n()>1) %>%   
  distinct(SummonerMatchFk, Lane, .keep_all = TRUE) %>% 
  arrange(SummonerMatchFk) %>%   
  filter(n()>1) %>% 
  group_by(SummonerMatchFk) %>% 
  mutate(tally_person = row_number()) %>% 
  filter(tally_person == 2) -> table2

MSI_Tbl %>% 
   group_by(SummonerMatchFk) %>% 
  filter(n()>1) %>%   
  distinct(SummonerMatchFk, Lane, .keep_all = TRUE) %>% 
  arrange(SummonerMatchFk) %>%   
  filter(n()>1) %>% 
  group_by(SummonerMatchFk) %>% 
  mutate(tally_person = row_number()) %>% 
  filter(tally_person == 1) %>%  
  select(SummonerMatchFk, SecondLane = Lane) -> table1

MSI_Tbl_doubles <- full_join(table1, table2, join_by(SummonerMatchFk))
rm(table1)
rm(table2)


MSI_Tbl <- MSI_Tbl %>% 
  group_by(SummonerMatchFk) %>% 
  anti_join(MSI_Tbl_doubles, join_by(SummonerMatchFk)) %>%
  mutate(SecondLane = NA) %>% 
  rbind(MSI_Tbl_doubles) %>% 
  distinct(SummonerMatchFk, .keep_all = TRUE) %>%
  select(-tally_person, -item1,-item2,-item3,-item4,-item5,-item6) %>% 
  arrange(SummonerMatchFk) 

rm(MSI_Tbl_doubles)

```

#Second Lane Data analysis for MSI Kills Column
```{r}
 MSI_Tbl %>% 
  select(SecondLane,kills) %>% 
  drop_na(SecondLane) %>% 
  group_by(SecondLane) %>%
  count(SecondLane, wt = kills) %>% 
  rename(kills = n) %>% 
  view()

```


#Second Lane Data analysis for MSI Kills Column plot
```{r, echo=FALSE}
ggplotly(ggplot( MSI_Tbl %>% 
  select(SecondLane,kills) %>% 
  drop_na(SecondLane) %>% 
  group_by(SecondLane) %>%
  count(SecondLane, wt = kills) %>% 
  rename(kills = n), 
  aes(x = SecondLane, y = kills, fill = SecondLane, text = paste("Count:", after_stat(y))))
  + geom_col(), 
  tooltip = "text", 
  na.rm = TRUE )

```


#Lane Data analysis for MSI kills Column 
```{r}
 MSI_Tbl %>% 
  drop_na(Lane) %>% 
  group_by(Lane) %>%
  count(Lane, wt = kills) %>% 
  rename(kills = n) %>% 
  view()
```

#Lane Data analysis for MSI Kills Column plot
```{r}
ggplotly(ggplot( MSI_Tbl %>% 
  select(Lane,kills) %>% 
  drop_na(Lane) %>% 
  group_by(Lane) %>%
  count(Lane, wt = kills) %>% 
  rename(kills = n), 
  aes(x = Lane, y = kills, fill = Lane, text = paste("Count:", after_stat(y))))
  + geom_col(), 
  tooltip = "text", 
  na.rm = TRUE )

```



#Combine SMR and MSI Table 
```{r}

```





























```{r}

```






## Veronica

1. TMR_tbl create column (boolean) indicating who won. Lets combine TMR with Champion Table 

```{r}


```


2. TMR_tbl Filter teams with winning arams, classics based on rank. Bar graph & scatter plot x = rank, y = # of wins, color by queue types, density. face wrap

Let us look at all winning teams from each map type.
```{r}
#source(here::here("WinningTeams","app.R"))
#shinyApp(ui, server) 
#head(Team_Winner_Tbl, n = 10) 
```


3. TMR_tbl Filter winning teams, most used champion in red team and blue team 

```{r}



```


4. TMR_tbl find the mean, median, max and min (all kills) only for classic queue types

```{r}

TMR_Tble %>%
  filter(QueueType == "CLASSIC") %>% 
  summarise(
    Total_Mean_Kills = mean(RedKills + BlueKills, na.rm = TRUE),
    Total_Medium_Kills = median(RedKills + BlueKills, na.rm = TRUE),
    Max_Kills = max(RedKills + BlueKills, na.rm = TRUE),
    Red_Mean = mean(RedKills, na.rm = TRUE),
    Blue_Mean = mean(BlueKills, na.rm = TRUE),
    Red_Median = median(RedKills, na.rm = TRUE),
    Blue_Median = median(BlueKills, na.rm = TRUE),
    Red_Max = max(RedKills, na.rm = TRUE),
    Blue_Min = max(BlueKills, na.rm = TRUE)
    )

```


Team winner table mean min max of the for Both teams : Kills, Baron, Rift Herald, Dragon, Towers

```{r}
  
Team_Winner_Stats <-Team_Winner_Tbl %>%
  filter(Side %in% c("Red","Blue")) %>%
  filter(QueueType %in% c("CLASSIC", "ARAM","SWIFTPLAY","ULTBOOK")) %>% 
  group_by(Side, QueueType) %>% 
  summarise(MeanKills = mean(Kills, na.rm = TRUE),
            MinKills = min(Kills, na.rm = TRUE),
            MaxKills = max(Kills, na.rm = TRUE),
            MeanBaron = mean(BaronKills, na.rm = TRUE),
            MinBaron = min(BaronKills, na.rm = TRUE),
            MaxBaron = max(BaronKills, na.rm = TRUE),
            MeanRiftHeraldKills = mean(RiftHeraldKills, na.rm = TRUE),
            MinRiftHeraldKills = min(RiftHeraldKills, na.rm = TRUE),
            MaxRiftHeraldKills = max(RiftHeraldKills, na.rm = TRUE),
            MeanDragonKills = mean(DragonKills, na.rm = TRUE),
            MinDragonKills = min(DragonKills, na.rm = TRUE),
            MaxDragonKills = max(DragonKills, na.rm = TRUE),
            MeanTowerKills = mean(TowerKills, na.rm = TRUE),
            MinTowerKills = min(TowerKills, na.rm = TRUE),
            MaxTowerKills = max(TowerKills, na.rm = TRUE))

view(Team_Winner_Stats)
```


```{r}

```

```{r}

  
```

# Bar plot 
```{r}
ggplotly(ggplot(Team_Winner_Stats, aes(x = QueueType, y = MeanKills, fill = Side,text = paste("Count:", after_stat(y)))) + geom_col() + facet_wrap(~Side), tooltip = "text")
```

```{r}
ggplotly(ggplot(Team_Winner_Stats %>% 
                  filter(QueueType!= "ARAM"), aes(x = QueueType, y = MeanBaron, fill = Side,text = paste("Count:", after_stat(y)))) + geom_col() + facet_wrap(~Side), tooltip = "text")
```

```{r}
ggplotly(ggplot(Team_Winner_Stats %>% 
                  filter(QueueType!= "ARAM"), aes(x = QueueType, y = MeanRiftHeraldKills, fill = Side,text = paste("Count:", after_stat(y)))) + geom_col() + facet_wrap(~Side), tooltip = "text")
```


7.each player and the amount of games they play per queue type 

```{r}
Player_Games <- SMR_Tbl %>% 
  select(SummonerFk,QueueType,RankFk,RankName) %>% 
  group_by(QueueType, SummonerFk, RankName) %>%
  summarise(games = n()) %>% 
  arrange(SummonerFk)

```

How many players play in each queue type, a player can play multiple queue types in league of legends. No map restriction.
```{r}

ggplotly(ggplot(Player_Games,aes(x = QueueType, fill = QueueType, text = paste("Count:", after_stat(count)))) + geom_bar(), tooltip = "text", na.rm = TRUE)

```

```{r}
Player_Games %>%
  group_by(RankName) %>% 
  distinct(SummonerFk,.keep_all = TRUE) %>% 
  summarise(n=n()) %>% 
  drop_na(RankName) %>% 
  rename(Players = n)
```


What rank players fall in in this data set. 

```{r}
ggplotly(ggplot(Player_Games %>%
  group_by(RankName) %>% 
  distinct(SummonerFk,.keep_all = TRUE) %>% 
  summarise(n=n()) %>% 
  drop_na(RankName) %>% 
  rename(Players = n),aes(x = RankName, y = Players, fill = RankName, text = paste("Count:", after_stat(y)))) + geom_col(), tooltip = "text", na.rm = TRUE)

```

Fun fact: 
```{r}

```

