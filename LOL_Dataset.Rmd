---
title: "LOL_Dataset_Project"
author: "Tamana Yaqoubi, Veronica Alviso"
date: "2025-11-04"
output: html_document
runtime: shiny
---

## About the dataset 
https://www.kaggle.com/datasets/nathansmallcalder/lol-match-history-and-summoner-data-80k-matches

- The data comes from European reign called League of Legends
- Shows team analysis and per player analysis providing insight stats in KDA, items, characters "champions', winning, etc 
- The dataset comes from Kaggle.com
##Introduction 
This dataset provides comprehensive match and player information from League of Legends, one of the worldâ€™s most popular multiplayer online battle arena (MOBA) games. It features data from 35,000 matches and over 78,000 player records, covering various in-game aspects such as champion choices, performance metrics, match results, and other gameplay statistics. This dataset consist of 7 tables: MatchStatsTbl, TeamMatchStatsTbl, MatchTbl, RankTble, ChampionTbl, ItemTbl, SummonerTbl, and SummonerMatchTbl. 



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidyr)
library(dplyr)
library(ggplot2)
library(kableExtra)
library(gridExtra)
library(plotly)
library(shiny)
library(here)
library(knitr)
#source("R_Data_Prep.R")
#data_dir <- here::here(".")

```

## Read csv files
```{r}
'
championTbl <- read_tbl("ChampionTbl")
itemTbl<- read_tbl("ItemTbl")
matchStatsTbl <- read_tbl("MatchStatsTbl")
matchTbl <- read_tbl("MatchTbl")
RankTbl <- read_tbl("RankTbl")
SummonerMatchTbl <- read_tbl("SummonerMatchTbl")
TeamMatchTbl <- read_tbl("TeamMatchTbl")
'
```


## View datasets
```{r}
head(championTbl) %>% knitr::kable()
head(itemTbl) %>% knitr::kable()
head(matchStatsTbl) %>% knitr::kable()
head(matchTbl) %>% knitr::kable()
head(RankTbl, n = 11) %>% knitr::kable()
head(SummonerMatchTbl) %>% knitr::kable()
head(TeamMatchTbl) %>% knitr::kable()

```


## Champion Table -VA

The following the data set has basically an NA value named 'No champion'. The data set has been updated so that it only represents actual champions that are playable in League of Legends.

```{r}
championTbl <- championTbl %>% 
  filter(ChampionId > 0)

championTbl %>% kbl() %>% kable_styling() %>% 
scroll_box(width = "100%", height = "400px")

kable(championTbl, align = "r")
```

As you can see, there is no longer a champion ID 0 - No champion. Using the dplyr function filter we successfully removed any irrelevant or not needed rows. 

## MSI Table -TY
Creating a new table called 'MSI_Tbl' to join the Match Stats table and Item Table

ooo;'



## match_rank Table -VA

We have created a new table called match_rank_tbl.
The purpose of this table is to join both the match table and the rank table by their RankFk == RankId. This will let us know whether the match was ranked or unranked.

```{r}
'match_rank_tbl <- full_join(matchTbl,RankTbl,join_by(RankFk == RankId))'
match_rank_tbl %>% kbl() %>% kable_styling() %>% 
scroll_box(width = "100%", height = "400px")
```



## TMR Tbl -TY
Create new table called 'TMM_Tbl' to join Team Match Table and Match Table

```{r, echo = F}
'TMR_Tble <- full_join(TeamMatchTbl, match_rank_tbl, by = join_by(MatchFk == MatchId))'
TMR_Tble %>% kbl() %>% kable_styling() %>% 
scroll_box(width = "100%", height = "400px")
```



## SMR tbl -VA

The following table was created in order to join both the summoner match table and a match rank table.
This table displays a smaller depiction 


```{r}
'SMR_Tbl <- full_join(SummonerMatchTbl, championTbl, join_by(ChampionFk == ChampionId))

SMR_Tbl <- full_join(SMR_Tbl, match_rank_tbl, by = join_by(MatchFk == MatchId))'
SMR_Tbl %>% kbl() %>% kable_styling() %>% 
scroll_box(width = "100%", height = "400px")
```

## Joining SMR table and MSI table -TY
```{r}
#SMRI_tbl <- full_join(SMR_Tbl, MSI_Tbl, by = join_by(SummonerMatchId==SummonerMatchFk))
#SMRI_tbl 
#Needs further filtering 
```



## Tamana MSI_tbl and Match_rank_tbl dplyr and plot functions

#MSI_Tbl

MSI_Tbl
```{r}
MSI_Tbl %>% kbl() %>% kable_styling() %>% 
scroll_box(width = "100%", height = "400px")
```

1. How many SummonerMatchFk play more than one lane


```{r}
MSI_Tbl %>%
  group_by(SummonerMatchFk)%>%
  summarise(num_lanes = n_distinct(Lane))%>% #count the unique lanes
  filter(num_lanes > 1)%>%
  summarise(total_players = n())

```


2.Find the Mean, Median, Max, and Min for the following:
- minions killed
- TurretDmg
- DmgTaken
- DmgDealt
- totalGold.


Mean median min and max of minions kiled: 
```{r, echo = F}
MSI_Tbl%>%
  summarise(avg_minionsKilled = mean(MinionsKilled, na.rm = T),
            median_minionsKilled = median(MinionsKilled, na.rm = T),
            min_minionsKilled = min(MinionsKilled, na.rm = T),
            max_minionsKilled = max(MinionsKilled, na.rm = T))
```


mean, median, min, and max of TurretDmg:
```{r,  echo = F}
MSI_Tbl%>%
  summarise(avg_TurretDmgDealt = mean(TurretDmgDealt, na.rm = T),
            median_TurretDmgDealt = median(TurretDmgDealt, na.rm = T),
            min_TurretDmgDealt = min(TurretDmgDealt, na.rm = T), 
            max_TurretDmgDealt = max(TurretDmgDealt, na.rm = T))

```


mean, median, min, and max of DmgTaken:
```{r, echo = F}
MSI_Tbl%>%
  summarise(avg_DmgTaken = mean(DmgTaken, na.rm = T),
            median_DmgTaken = median(DmgTaken, na.rm = T), 
            min_DmgTaken = min(DmgTaken, na.rm = T),
            max_DmgTaken = max(DmgTaken, na.rm = T))

```


mean, median, min, and max of DmgDealt:
```{r, echo = F}

MSI_Tbl%>%
  summarise(avg_DmgDealt = mean(DmgDealt, na.rm = T),
            median_DmgDealt = median(DmgDealt, na.rm = T), 
            min_DmgDealt = min(DmgDealt, na.rm = T),
            max_DmgDealt = max(DmgDealt, na.rm = T))
```


mean, median, min, and max of totalGold:
```{r, echo = F}
MSI_Tbl%>%
  summarise(avg_TotalGold = mean(TotalGold, na.rm = T),
            median_TotalGold = median(TotalGold, na.rm = T), 
            min_TotalGold = min(TotalGold, na.rm = T),
            max_TotalGold = max(TotalGold, na.rm = T))
```


3. Create new column (boolean) for indicating win or lose. Filter to win and lose only and create a ggplots.

```{r, echo = F}
MSI_Tbl%>%
  mutate(won = Win != 1)%>%
  drop_na(won)%>% 
  ggplot(aes(x=won, fill=won)) + 
  geom_bar() +
  labs(title = "Win vs. Lose")
```


4. MSI_tbl (ask professor) Items, filter NAs from item names, count total items, most popular items, least popular items. Median and mean items a player holds. 


```{r}
#Removing NAs from the MSI_Tbl
temp_MSI <- MSI_Tbl%>%
  drop_na(ItemName, ItemName_2, ItemName_3, ItemName_4, ItemName_5, ItemName_6)

#Combining the item name columns into one single column
temp_MSI_Tbl <- MSI_Tbl%>%
  pivot_longer(
    cols = starts_with("ItemName"), # automatically combines columns
    names_to = "Items",             # new column that stores old columns 
    values_to = "ItemNames"         # new column that has the combined columns
     )

#Count the total number of items
new_temp_MSI_Tbl <- temp_MSI_Tbl %>% 
  group_by(ItemNames) %>% 
  summarise(Total_Items=n())

#Find most popular items
new_temp_MSI_Tbl%>% 
  slice_max(Total_Items, n=10)

#least popular item
new_temp_MSI_Tbl %>% 
  slice_min(Total_Items)

#join temp_MSI_Tbl and new_temp_MSI_Tbl to get the mean and median of items a player holds.
N_MSI_Tbl <- full_join(temp_MSI_Tbl, new_temp_MSI_Tbl, by = join_by(ItemNames))


#Mean and median of items a player holds
new_temp_MSI_Tbl %>% 
  drop_na(ItemNames) %>% 
  group_by(ItemNames) %>% 
  summarise(Items_used_avg = mean(Total_Items), 
            Items_used_median = median(Total_Items))

```


5. Plot game duration as the Y value and Queue type as the X value, filter based on RankName.
```{r}
match_rank_tbl %>%
  group_by(RankName)%>%
  summarise(Duration= n())

ggplot(match_rank_tbl, aes(x = GameDuration, color= QueueType)) + 
  geom_density() + 
  labs(title = "Game Duration")
```


```{r}

ggplot(matchStatsTbl, aes(x= kills, color = Lane)) + geom_density() + facet_wrap(~Lane)
```


6. Analyze if totalgold or dmgdealt increases the chances of winning
```{r}
ggplot(MSI_Tbl, aes(x = TotalGold, y = DmgDealt, color = Win)) + geom_point(alpha = 0.3) + 
  labs(title="Win: Total Gold vs Damage Dealt",
       x = "Total Gold",
       y = "Damage Dealt")
  
```


7. Plot top 10 popular items 
```{r}
Top_Items <- new_temp_MSI_Tbl%>% 
  slice_max(Total_Items, n = 10)

ggplotly(ggplot(Top_Items, aes(x=ItemNames, y = Total_Items, fill = ItemNames, text = paste("Count:", after_stat(y)))) + geom_boxplot() + 
           labs(
             title ="Top 10 Items",
             x = "Item Names",
             y = "Total Items"), tooltip = "text")

``` 

  
8. Plot top 10 champions
```{r}
champs <- SMR_Tbl %>%
  group_by(ChampionName) %>% 
  summarise(num_champs = n())

Top_champs <- champs %>% 
  slice_max(num_champs, n = 10)

ggplotly(ggplot(Top_champs, aes(x = ChampionName, y = num_champs, fill = ChampionName, text = paste("Count:", after_stat(y)))) + geom_col() + 
           labs(title = "Top 10 Champions", 
                x = "Champions Name",
                y = "Number of Champions"), tooltip = "text")

```


9. Show what lane would have more kills
```{r}
#waiting for the new MSI table after to merge
ggplot(MSI_Tbl, aes(x = Lane)) + geom_col() + labs(title= "Kills vs Lane")

```


10. Find mean, min, max of visionscore and plot mean of visionScore for winning and loosing teams
```{r}
MSI_Tbl %>% 
  group_by(Win) %>% 
  summarise(VS_avg = mean(visionScore, na.rm =T),
            VS_min = min(visionScore, na.rm =T), 
            VS_max = max(visionScore, na.rm =T))

ggplot(VS, aes(x = as.factor(Win), y = VS_avg, fill = as.factor(Win))) +
  geom_col() + 
  scale_x_discrete(labels = c("1" = "Win", "0" = "Lose")) + 
  labs(
   title = "Vision Score: Winning vs Losing",
       x = "win/lose",
       y = "Vision Score Average"
    )

```


11. Analyze if higher visionScore mean more wins
```{r}
ggplot(MSI_Tbl, aes(x = visionScore, color = factor(Win))) + geom_density(alpha = 0.4) + 
  labs(title = "Vision Score: Winning vs Losing Teams",
       x= "Vision Score")
```


12. Compare kills and Lane 
```{r}
#wait till after we merge cuz we need the new table
ggplotly(ggplot(MSI_Tbl, aes(x = Lane, y = kills, fill = Lane, text = paste("Count:", after_stat(y)))) + geom_col() + labs(title = "Kills vs lane"), tooltip= "text") 
```


```{r}
MSI_Tbl %>% 
  slice_max(kills) 
```










































## Veronica

1. TMR_tbl create column (boolean) indicating who won.

```{r}
head(TMR_Tble)
```


2. TMR_tbl Filter teams with winning arams, classics based on rank. Bar graph & scatter plot x = rank, y = # of wins, color by queue types, density. face wrap

Let us look at all winning teams from each map type.
```{r}
source(here::here("WinningTeams","app.R"))
shinyApp(ui, server) 
head(Team_Winner_Tbl, n = 10) 
```


3. TMR_tbl Filter winning teams, most used champion in red team and blue team 

```{r}



```


4. TMR_tbl find the mean, median, max and min (all kills) only for classic queue types

```{r}

TMR_Tble %>%
  filter(QueueType == "CLASSIC") %>% 
  summarise(
    Total_Mean_Kills = mean(RedKills + BlueKills, na.rm = TRUE),
    Total_Medium_Kills = median(RedKills + BlueKills, na.rm = TRUE),
    Max_Kills = max(RedKills + BlueKills, na.rm = TRUE),
    Red_Mean = mean(RedKills, na.rm = TRUE),
    Blue_Mean = mean(BlueKills, na.rm = TRUE),
    Red_Median = median(RedKills, na.rm = TRUE),
    Blue_Median = median(BlueKills, na.rm = TRUE),
    Red_Max = max(RedKills, na.rm = TRUE),
    Blue_Min = max(BlueKills, na.rm = TRUE)
    )
  
```


```{r}

```

5. TMR_tbl Count the number game plays per queue types plot

```{r}
ggplotly( ggplot(TMR_Tble,aes(x = QueueType, fill = QueueType, text = paste("Count:", after_stat(count)))) + geom_bar(), tooltip = "text")
```


7. SMR_tbl: Top 10 people that play: Queue types. - instead found each player and the amount of games they play per queue type 

```{r}
Player_Games <- SMR_Tbl %>% 
  select(SummonerFk,QueueType,RankFk,RankName) %>% 
  group_by(QueueType, SummonerFk, RankName) %>%
  summarise(games = n()) %>% 
  arrange(SummonerFk)
  

ggplotly(ggplot(Player_Games,aes(x = QueueType, fill = QueueType, text = paste("Count:", after_stat(count)))) + geom_bar(), tooltip = "text", na.rm = TRUE)

#ggplotly(ggplot(Player_Games,aes(x = QueueType, y = RankName, color = QueueType) + geom_bar(), tooltip = "text", na.rm = TRUE)

```

```


8. SMR_tbl:  Histogram champions

```{r}
#CHANGE

```


9. SMR_tbl: Filter MSI_table to only have matchID and wins. Join with SMR table. Calculate the top 10 players with the most wins.

```{r}

```

