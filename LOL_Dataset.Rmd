---
title: "LOL_Dataset_Project"
author: "Tamana Yaqoubi, Veronica Alviso"
date: "2025-11-04"

output:
  slidy_presentation:
    self_contained: true
    highlight: null
    fig_width: 10
    fig_height: 6
    fig_retina: 3
---

# About the dataset 

Source:
https://www.kaggle.com/datasets/nathansmallcalder/lol-match-history-and-summoner-data-80k-matches

- The data comes from League of legends (European Region). 
- Includes team and player analysis providing insight stats in kills, deaths, assists, items, champion selections, game results, etc.  
- All the data obtained is from Kaggle.com

# Introduction 

The data downloaded provides comprehensive match and player information from League of Legends, one of the worldâ€™s most popular multi-player online battle arena (MOBA) games. 

It features data from 35,000 matches and over 78,000 player records, covering various in-game aspects such as champion choices, performance metrics, match results, and other game play statistics. 

The data is organized into7 CSV tables: 
1. MatchStatsTbl
2. TeamMatchStatsTbl
3. MatchTbl
4. RankTbl 
5. ChampionTbl 
6. ItemTbl 
7. SummonerMatchTbl. 

Data excluded: Summoner data due to privacy restrictions, the owners of the data did not share. 

### League of Legends Terminology

- **Champions(Champs)** : The characters that players play.
- **Queue Type**: The Game mode. ( 5v5, 2v2 1v1)
- **Lane**: Players dictate which lane they would like to play in certain maps such as classic.
- **Rank**: Level of player, Higher rank better player. 
- **Minions**: little soldiers, each team gets little soldiers. 
- **K/D/A**: Kills, Death, Assists

### Functions used

- **dplyr** : Used for data cleaning, selecting, filtering..
- **ggplot**: Plotting density, bar, jitter plots, smooth curves, faceted graphs
- **plotly**: Interactive graphs
- **Kable Extra**: Scrollable tables and better visualization of tables
- **Grid Extra**: Combining multiple grids
- **Joined functions**: Used to build combined tables


# Combined (Joined) Data

What we did is join most of our data sets to have a more efficient data structure. The following data sets were created:
 
 
```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  #eval = FALSE 
  cache   = TRUE 
)

library(tidyverse)
library(tidyr)
library(dplyr)
library(ggplot2)
library(kableExtra)
library(gridExtra)
library(plotly)
library(shiny)
library(here)
library(knitr)
library(grid)
library(DT)
source("R_Data_Prep.R")

```

**ChampionTbl** is the original dataset. 

```{r, echo=FALSE}
DT::datatable(
  head(championTbl, 10),
  options = list(pageLength = 10)
)
```

**match_rank_tbl**: This table displays every match in EU region with the following information: Queue type, Rank, Game duration. 

```{r, echo=FALSE}

DT::datatable(
  head(match_rank_tbl, 10),
  options = list(pageLength = 10)
)
```


**TMR_Tble**: Team match rank table is a combined data of one original csv file and a combined data set. TeamMatchTbl and match_rank_tbl. Shows detailed team statistics. 

```{r, echo=FALSE}
# TMR_Tble %>%
#   slice_head(n = 10)
#   #%>%
#   # kbl() %>%
#   # kable_styling() %>%
#   # scroll_box(width = "100%", height = "400px")
```

```{r}
DT::datatable(
  head(TMR_Tble, 10),
  options = list(pageLength = 10)
)
```
---

**SMR_Tbl**: This table displays the players key detailed match stats.

```{r, echo=FALSE}
DT::datatable(
  head(SMR_Tbl, 10),
  options = list(pageLength = 10)
)
```


**Team_Winner_Tbl**: This table only shows teams that have won from TMR_Tble.

```{r, echo=FALSE}
DT::datatable(
  head(Team_Winner_Tbl, 10),
  options = list(pageLength = 10)
)
```


**MSI_Tbl**: This table set will display the players detailed match stats which include kills for both enemy champions and monsters affiliated and include item purchase and summoner spells.



```{r, echo=FALSE}
MSI_Tbl %>%
   group_by(SummonerMatchFk) %>%
  filter(n()>1) %>%
  distinct(SummonerMatchFk, Lane, .keep_all = TRUE) %>%
  arrange(SummonerMatchFk) %>%
  filter(n()>1) %>%
  group_by(SummonerMatchFk) %>%
  mutate(tally_person = row_number()) %>%
  filter(tally_person == 2) -> table2

MSI_Tbl %>%
   group_by(SummonerMatchFk) %>%
  filter(n()>1) %>%
  distinct(SummonerMatchFk, Lane, .keep_all = TRUE) %>%
  arrange(SummonerMatchFk) %>%
  filter(n()>1) %>%
  group_by(SummonerMatchFk) %>%
  mutate(tally_person = row_number()) %>%
  filter(tally_person == 1) %>%
  select(SummonerMatchFk, SecondLane = Lane) -> table1

MSI_Tbl_doubles <- full_join(table1, table2, join_by(SummonerMatchFk))
rm(table1)
rm(table2)


MSI_Tbl <- MSI_Tbl %>%
  group_by(SummonerMatchFk) %>%
  anti_join(MSI_Tbl_doubles, join_by(SummonerMatchFk)) %>%
  mutate(SecondLane = NA) %>%
  rbind(MSI_Tbl_doubles) %>%
  distinct(SummonerMatchFk, .keep_all = TRUE) %>%
  select(-tally_person, -item1, -item2,-item3, -item4, -item5,-item6) %>%
  arrange(SummonerMatchFk)

rm(MSI_Tbl_doubles)

```

```{r, echo=FALSE}
DT::datatable(
  head(MSI_Tbl, 10),
  options = list(pageLength = 10)
)
```



# Lets Look at Team Stats!

Why is this interesting? 

Well in league of legends, **all sorts of kills are important.**

- **Gold is the biggest objective**, and it is mainly gained through all sorts of minion kills and enemy champion kills, this allows for solo lane or paired players to buy items that are necessary to get stronger. 

- **Baron kills** gives your whole team a chunk of gold and advanced stats for a period of time, leading to a higher chance of winning, **dragons** on the other hand do not provide gold but do enhance stats.

- **Tower Kills** are important because you get gold and you get an advantage around the map, providing map pressure by allowing your minions to move up without restriction.  


**Fun fact** there are several types of dragons: Infernal, Ocean, Mountain, Chemtec, Hextech, Cloud and Elder dragon.


```{r, echo=FALSE}
#Team win statistics : mean, min, max for Kills, Baron, Rift Herald, Dragon, Towers

Team_Winner_Stats <-Team_Winner_Tbl %>%
  filter(Side %in% c("Red","Blue")) %>%
  filter(QueueType %in% c("CLASSIC", "ARAM","SWIFTPLAY","ULTBOOK")) %>% 
  group_by(Side, QueueType) %>% 
  summarise(MeanKills = mean(Kills, na.rm = TRUE),
            MinKills = min(Kills, na.rm = TRUE),
            MaxKills = max(Kills, na.rm = TRUE),
            MeanBaron = mean(BaronKills, na.rm = TRUE),
            MinBaron = min(BaronKills, na.rm = TRUE),
            MaxBaron = max(BaronKills, na.rm = TRUE),
            MeanRiftHeraldKills = mean(RiftHeraldKills, na.rm = TRUE),
            MinRiftHeraldKills = min(RiftHeraldKills, na.rm = TRUE),
            MaxRiftHeraldKills = max(RiftHeraldKills, na.rm = TRUE),
            MeanDragonKills = mean(DragonKills, na.rm = TRUE),
            MinDragonKills = min(DragonKills, na.rm = TRUE),
            MaxDragonKills = max(DragonKills, na.rm = TRUE),
            MeanTowerKills = mean(TowerKills, na.rm = TRUE),
            MinTowerKills = min(TowerKills, na.rm = TRUE),
            MaxTowerKills = max(TowerKills, na.rm = TRUE)) 


TW_RENAMED <- Team_Winner_Stats %>% 
  rename('Queue Type' = QueueType) %>% 
  rename('Mean Kills' = MeanKills) %>% 
  rename('Min Kills' = MinKills) %>% 
  rename('Max Kills'= MaxKills) %>% 
  rename('Mean Baron' = MeanBaron) %>% 
  rename('Min Baron' = MinBaron) %>% 
  rename('Max Baron' = MaxBaron) %>% 
  rename('Mean Rift Herald Kills' = MeanRiftHeraldKills) %>% 
  rename('Min Rift Herald Kills' = MinRiftHeraldKills) %>% 
  rename('Max Rift Herald Kills' = MaxRiftHeraldKills) %>% 
  rename('Mean Dragon Kills' = MeanDragonKills) %>% 
  rename('Min Dragon Kills' = MinDragonKills) %>% 
  rename('Max Dragon Kills' = MaxDragonKills) %>% 
  rename('Mean Tower Kills' = MeanTowerKills) %>% 
  rename('Min Tower Kills' =MinTowerKills) %>% 
  rename('Max Tower Kills' =MaxTowerKills) 
 
DT::datatable(
  TW_RENAMED,
  options = list(
    scrollX = TRUE,
    pageLength = 10,
    lengthMenu = c(10, 20, 30),
    autoWidth = TRUE
  )
)

```

```{r, echo=FALSE}
common_theme <- theme_minimal(base_size = 14) +
  theme(
    axis.title.y = element_text(size = 10, face = "bold"),
    axis.title.x = element_text(size = 10, face = "bold"),
    axis.text = element_text(size = 10)
  )

```


### Mean of Kills, Baron Kills, Rift Herald Kills, Dragon Kills, Tower Kills 

Why is it that the mean for Baron, Rift and Dragon Kills is smaller than regular kills?

- Dragons spawn every 5 to 7 minutes throughout the game. 

- Rift Herald first spawn is at 15 minutes. 

- Baron's first spawn is at 25 min, if baron is defeated, the boost last about 3 mins. Then afterwards the baron will spawn every 5 to 6 minutes. 

- Game duration plays a big part in Summoners Rift Map (CLASSIC) and other maps as well such as ARAM. 

**Fun fact:** The first Baron must be defeated with at least 3-4 players, or else you will die. Afterwards 2 players is enough but it takes time to defeat Baron, not an easy tasks to do alone. 


```{r, echo=FALSE}
a1 <- ggplot(Team_Winner_Stats, aes(x = QueueType, y = MeanKills, fill = Side)) + geom_col(width = 1) + ggtitle("Average Kills") + coord_flip() + common_theme + labs(x = NULL, y = NULL) + guides(fill = "none")

a2 <- ggplot(Team_Winner_Stats %>% 
               filter(QueueType != "ARAM"), aes(x = QueueType, y = MeanBaron, fill = Side)) + geom_col(width = 1) + ggtitle("Average Baron Kills") + coord_flip() + common_theme + labs(x = NULL, y = NULL) + guides(fill = "none")

a3 <- ggplot(Team_Winner_Stats %>% 
               filter(QueueType != "ARAM") %>% 
               filter(MeanRiftHeraldKills != 0), aes(x = QueueType, y = MeanRiftHeraldKills, fill = Side)) + geom_col(width = 1) + ggtitle("Average Rift Herald Kills") + coord_flip() + common_theme + labs(x = NULL, y = NULL) + guides(fill = "none")

a4 <- ggplot(Team_Winner_Stats %>% 
               filter(QueueType != "ARAM"), aes(x = QueueType, y = MeanDragonKills, fill = Side)) + geom_col(width = 1) + ggtitle("Average Dragon Kills") + coord_flip() + common_theme + labs(x = NULL, y = NULL) + guides(fill = "none")
 
a5 <- ggplot(Team_Winner_Stats, aes(x = QueueType, y = MeanTowerKills, fill = Side)) + geom_col(width = 1) + ggtitle("Average Tower Kills") + coord_flip() + common_theme + labs(y = NULL, x = NULL) 

```


```{r, echo= FALSE}
grid.arrange(a1,a3,a4,a5,a2, nrow = 3, ncol = 2, top = "Team Winner Statistics", left = "Queue Type", bottom = "Average Count")
```


Looking at Dragons vs Baron vs Rift Herald, we can see that Dragons are killed more frequently. Spawning is a factor, also you do not need many members to kill a dragon, unless it is the elder dragon. 

**We can see that Aram and Classic both hold high mean kills, why is that?**

---

### Max of Kills, Baron Kills, Rift Herald Kills, Dragon Kills, Tower Kills 

Max kills vary through map, as you can see not that many kills in swiftplay, some maps have shorter and more difficult objectives during game, making it more difficult to kill. 

We **did not include ARAM** for Baron, Dragon and Rift Herald kills. 
- This is simple is because they do not have those monsters in that type of QUEUETYPE
- Also you might see CHERRY missing, this is also important to point out, they are an arena type of map. Their teams consist of 2 players instead of the typical 5.


```{r, echo=FALSE}
b1 <- ggplot(Team_Winner_Stats, aes(x = QueueType, y = MaxKills, fill = Side)) + geom_col(width = 1) + ggtitle("Max Kills") + coord_flip() + common_theme + labs(x = NULL, y = NULL)  + guides(fill = "none")

b2 <- ggplot(Team_Winner_Stats %>% 
               filter(QueueType != "ARAM"), aes(x = QueueType, y = MaxBaron, fill = Side)) + geom_col(width = 1) + ggtitle("Max Baron Kills") + coord_flip() + common_theme + labs(x = NULL, y = NULL) + guides(fill = "none")

b3 <- ggplot(Team_Winner_Stats %>% 
               filter(QueueType != "ARAM") %>% 
               filter(MeanRiftHeraldKills != 0), aes(x = QueueType, y = MaxRiftHeraldKills, fill = Side)) + geom_col(width = 1) + ggtitle("Max Rift Herald Kills") + coord_flip() + common_theme + labs(x = NULL, y = NULL) + guides(fill = "none")

b4 <- ggplot(Team_Winner_Stats %>% 
               filter(QueueType != "ARAM"), aes(x = QueueType, y = MaxDragonKills, fill = Side)) + geom_col(width = 1) + ggtitle("Max Dragon Kills") + coord_flip() + common_theme + labs(x = NULL, y = NULL) + guides(fill = "none")
 
b5 <- ggplot(Team_Winner_Stats, aes(x = QueueType, y = MaxTowerKills, fill = Side)) + geom_col(width = 1) + ggtitle("Max Tower Kills") + coord_flip() + common_theme + labs(y = NULL, x = NULL) 

```


```{r, echo=FALSE}
grid.arrange(b1,b3,b4,b5,b2, nrow = 5, top = "Team Winner Statistics", left = "Queue Type", bottom = "Max Count") 

```


**Fun Fact** : Jungler usually kills the first dragon with the help of bottom and support.  



# Team Game Duration 

Lets go ahead and evaluate the Blue teams and Red teams 

**Blue Team**
- In Aram, Blue teams seem to require more kills to win a game.
- When Blue team has a lead in kills and the game duration is not long, they have a chance to win. 


```{r, echo=FALSE}
ggplot(TMR_Tble %>% 
         mutate(BlueWin = ifelse(BlueWin == 0,"Lose","Win")) %>% 
         drop_na(QueueType) %>% 
         drop_na(BlueWin), aes(x= GameDuration, y = BlueKills, color = BlueWin )) + 
  geom_jitter(alpha = 0.4) + 
  labs(title = "Game Duration vs Blue Kills by Queue Type",
       x = "Game Duration", 
       y = "Blue Kills") +
  facet_wrap(~QueueType)

```


**Red Team**
- The most difficult map for red team is ARAM. If they do not have a lead in kills early on they lose the game.
- Same goes for CLASSIC queue types, red team wins when they have more kills early on. 


```{r, echo=FALSE}

ggplot(TMR_Tble %>% 
         mutate(RedWin = ifelse(RedWin == 0,"Lose","Win")) %>% 
         drop_na(QueueType) %>% 
         drop_na(RedWin), aes(x= GameDuration, y = RedKills, color = RedWin )) + geom_jitter(alpha = 0.4) +
  labs(title = "Game Duration vs Red Kills by Queue Type", 
       x = "Game Duration", 
       y = "Red Kills") + 
  facet_wrap(~QueueType)

```



**What do we see? **


```{r, echo=FALSE}
TMR_Tble %>% 
  group_by(Winning_Team, QueueType) %>% 
  drop_na(Winning_Team) %>% 
  summarise(n=n()) %>% 
  rename("Wins" = n)
```


The following plot shows that most won games are from the red team. The kills are a combined total of both the winning and losing team. 


```{r, echo=FALSE}

ggplot(TMR_Tble %>% 
         mutate(TotalKills = rowSums(across(c(RedKills, BlueKills)), na.rm = TRUE)) %>%
         drop_na(Winning_Team), aes(x = GameDuration, y = TotalKills, color = Winning_Team)) +
  geom_jitter(alpha = 0.2) +
  labs(title = "Game Duration vs Total Kills by Queue Type", 
       x= "Game Duration", 
       y = "Total Kills") +
  facet_wrap(~QueueType) + 
  scale_color_manual(values = c("Red" = "red", "Blue" = "blue"))

```


**Fun Fact**: Some champions are better at early stages of the game. Basically as the game duration continues the champion becomes more and more useless.


# Winning Teams

Lets look at the winning teams more deeply.

**This table shows that the Blue team has more overall kills than the Red team.**

```{r, echo=FALSE}
Team_Winner_Tbl %>% 
  count(Side, wt = Kills) %>% 
  rename(Kills = n)
```



```{r, echo=FALSE}
ggplot(Team_Winner_Tbl, aes(x = GameDuration, y = Kills, color = Side)) + geom_jitter( alpha= 0.5) +
  labs(title = "Game Duration vs Kills by Side", x = "Game Duration", y = "Kills") +
  scale_color_manual(values = c("Red" = "red", "Blue" = "blue"))

```



```{r, echo=FALSE}
ggplotly(ggplot(Team_Winner_Tbl, aes(x = GameDuration, y = Kills, color = QueueType)) +
           geom_point(alpha = 0.2) +
           labs(title = "Game Duration vs Kills by Queue Type", x = "Game Duration", y = "Kills"))

```


**What does this density curve mean?**
- The height of the line tells you how common a particular game duration is.
- Taller areas = more games lasted around that length.
- Shorter areas = fewer games lasted around that length


```{r, echo=FALSE}
ggplot(Team_Winner_Tbl, aes(x = GameDuration, color = Side)) + geom_density() + labs(title = "Distribution of Game Duration", x = "Game Duration", y = "Density") +  scale_color_manual(values = c("Red" = "red", "Blue" = "blue"))

```


```{r,echo=FALSE}

ggplot(Team_Winner_Tbl, aes(x = GameDuration, color = RankName)) + geom_density() +
  labs(title = "Distribution of Game Duration by Rank Name", x = "Game Duration", y = "Density") +
  facet_wrap(~RankName)

```



```{r, echo=FALSE}
#Plot game duration as the Y value and Queue type as the X value, filter based on RankName

rank_duration <- match_rank_tbl %>%
  group_by(RankName) %>%
  summarise(Games = n()) %>%
  arrange(desc(Games))

DT::datatable(
  rank_duration,
  options = list(
    pageLength = 10,
    autoWidth = TRUE,
    scrollX = TRUE
  ),
  rownames = FALSE
)
```



```{r, echo=FALSE}
#Plot game duration as the Y value and Queue type as the X value, filter based on RankName
ggplot(match_rank_tbl, aes(x = GameDuration, color= QueueType)) + 
  geom_density() + 
  labs(title = "Distribution of Game Duration by Queue Type", x = "Game Duration", y = "Density") 
```


```{r, echo=FALSE}
ggplot(matchStatsTbl, aes(x= kills, color = Lane)) + geom_density() + 
  labs(title ="Distribution of Kills by Lane", x = "Kills", y = "Density") + 
  facet_wrap(~Lane)
```


**Fun Fact**: Summoners Rift (CLASSIC) sometimes last 50 minutes or longer.  



# Lets look at Player Stats!

Its amazing when you are stacked.

A players stats are important, they can break or make a team. 

- Inflicting damage is great to look at, if you don't make enough damage, your hits are basically non existent to an enemy that is stacked. 

- Killing minions is very important, you get gold by killing them, and gold is amazing.

- Dealing damage when you have the right items, basically unstoppable.

- Taking damage not so great but can be reduced.


```{r, echo=FALSE}

TEMP_MSI_RENAME <-MSI_Tbl%>%
  ungroup() %>% 
  summarise('Avg Gold Total'= mean(TotalGold, na.rm = TRUE),
            'Median Total Gold' = median(TotalGold, na.rm = TRUE), 
            'Min Total Gold' = min(TotalGold, na.rm = TRUE),
            'Max Total Gold' = max(TotalGold, na.rm = TRUE),
            'Avg Minions Killed' = mean(MinionsKilled, na.rm = TRUE),
            'Median Minions Killed' = median(MinionsKilled, na.rm = TRUE),
            'Min Minions Killed' = min(MinionsKilled, na.rm = TRUE),
            'Max Minions Killed' = max(MinionsKilled, na.rm = TRUE),
            'Avg Damage Dealt' = mean(DmgDealt, na.rm = TRUE),
            'Median Damage Dealt' = median(DmgDealt, na.rm = TRUE), 
            'Min Damage Dealt' = min(DmgDealt, na.rm = TRUE),
            'Max Damage Dealt' = max(DmgDealt, na.rm = TRUE),
            'Avg Damage Taken' = mean(DmgTaken, na.rm = TRUE),
            'Median Damage Taken' = median(DmgTaken, na.rm = TRUE), 
            'Min Damage Taken' = min(DmgTaken, na.rm = TRUE),
            'Max Damage Taken' = max(DmgTaken, na.rm = TRUE),
            'Avg Turret Damage Dealt' = mean(TurretDmgDealt, na.rm = TRUE),
            'Median Turret Damage Dealt' = median(TurretDmgDealt, na.rm = TRUE),
            'Min Turret Damage Dealt' = min(TurretDmgDealt, na.rm = TRUE), 
            'Max Turret Damage Dealt' = max(TurretDmgDealt, na.rm = TRUE)) 
 

DT::datatable(
  TEMP_MSI_RENAME,
  options = list(
    scrollX = TRUE,
    pageLength = 10,
    lengthMenu = c(10, 20, 30),
    autoWidth = TRUE
  )
)

```


**Fun Fact**: You basically can die from 3 to 4 consecutive turret hits in the early stages of the game. The damage increases by 40% for each shot (up to a maximum bonus of 120%)


**A players role** is fundamental in scaling and advancing within the game. 
- A Classic game consists of 5 different roles (Top, Mid, Jungle, Bottom, Support) 

Why is it that Top lane on average deals more damage, kills, and receives more gold? 

In a Classic queue there are 3 lanes (Top, Middle, Bottom) but there is also a jungle in between those lanes. Now you only see 4 different paths so where does 5th role go ? Well they go bottom, Bottom and support are always together. 

```{r, echo=FALSE}
#Mean median min and max of minions killed: 
m <- MSI_Tbl%>%
  drop_na(MinionsKilled) %>%
  group_by(Lane) %>% 
  summarise(avg_minionsKilled = mean(MinionsKilled, na.rm = TRUE),
            median_minionsKilled = median(MinionsKilled, na.rm = TRUE),
            min_minionsKilled = min(MinionsKilled, na.rm = TRUE),
            max_minionsKilled = max(MinionsKilled, na.rm = TRUE))

mean1 <- ggplot(m, aes(x = avg_minionsKilled, y = Lane, fill = Lane)) + geom_col(width = 1) +  ggtitle("Average Minions Killed Per Lane" ) + common_theme + labs(x = NULL, y = NULL)

med1 <- ggplot(m, aes(x = median_minionsKilled, y = Lane, fill = Lane)) + geom_col(width = 1) + ggtitle("Median Minions Killed Per Lane") + common_theme + labs(x = NULL, y = NULL)

max1 <- ggplot(m, aes(x = max_minionsKilled, y = Lane, fill = Lane)) + geom_col(width = 1) +  ggtitle("Max Minions Killed Per Lane") + common_theme + labs(x = NULL, y = NULL)
```


```{r,  echo = FALSE}
#Mean median min and max of Turret Damage killed:

m <- MSI_Tbl%>%
  drop_na(TurretDmgDealt) %>% 
  group_by(Lane) %>% 
  summarise(avg_TurretDmgDealt = mean(TurretDmgDealt, na.rm = TRUE),
            median_TurretDmgDealt = median(TurretDmgDealt, na.rm = TRUE),
            min_TurretDmgDealt = min(TurretDmgDealt, na.rm = TRUE), 
            max_TurretDmgDealt = max(TurretDmgDealt, na.rm = TRUE))

mean2 <-ggplot(m, aes(x = avg_TurretDmgDealt, y = Lane, fill = Lane)) + geom_col(width = 1) +  ggtitle( "Average Damage Turret Dealt Per Lane") + common_theme + labs(x = NULL, y = NULL)  + guides(fill = "none")

med2 <- ggplot(m, aes(x = median_TurretDmgDealt, y = Lane, fill = Lane)) + geom_col(width = 1) + ggtitle("Median Damage Turret Dealt Per Lane") + common_theme + labs(x = NULL, y = NULL)  + guides(fill = "none")

max2 <- ggplot(m, aes(x = max_TurretDmgDealt, y = Lane, fill = Lane)) + geom_col(width = 1) +  ggtitle("Maximum of Damage Turret Dealt") + common_theme + labs(x = NULL, y = NULL)  + guides(fill = "none")
```


```{r, echo = FALSE}
#mean, median, min, and max of Damage Taken:

 m <- MSI_Tbl%>%
  drop_na(DmgTaken) %>% 
  group_by(Lane) %>% 
  summarise(avg_DmgTaken = mean(DmgTaken, na.rm = TRUE),
            median_DmgTaken = median(DmgTaken, na.rm = TRUE), 
            min_DmgTaken = min(DmgTaken, na.rm = TRUE),
            max_DmgTaken = max(DmgTaken, na.rm = TRUE))

mean3 <- ggplot(m, aes(x = avg_DmgTaken, y = Lane, fill = Lane)) + geom_col(width = 1) +  ggtitle("Average Damage Taken Per Lane") + common_theme + labs(x = NULL, y = NULL)  + guides(fill = "none")

med3 <- ggplot(m, aes(x = median_DmgTaken, y = Lane, fill = Lane)) + geom_col(width = 1) +  ggtitle("Median Damage Taken Per Lane") + common_theme + labs(x = NULL, y = NULL)  + guides(fill = "none")

max3 <- ggplot(m, aes(x = max_DmgTaken, y = Lane, fill = Lane)) + geom_col(width = 1) +  ggtitle("Maximum Damage Taken Per Lane") + common_theme + labs(x = NULL, y = NULL) + guides(fill = "none")
```


```{r, echo = FALSE}
#mean, median, min, and max of Damage Dealt:

 m<-MSI_Tbl%>%
  drop_na(DmgDealt) %>% 
  group_by(Lane) %>% 
  summarise(avg_DmgDealt = mean(DmgDealt, na.rm = TRUE),
            median_DmgDealt = median(DmgDealt, na.rm = TRUE), 
            min_DmgDealt = min(DmgDealt, na.rm = TRUE),
            max_DmgDealt = max(DmgDealt, na.rm = TRUE))

mean4 <-ggplot(m, aes(x = avg_DmgDealt, y = Lane, fill = Lane)) + geom_col(width = 1) + ggtitle("Average Damage Dealt Per Lane") + common_theme + labs(x = NULL, y = NULL)  + guides(fill = "none")


med4 <- ggplot(m, aes(x = median_DmgDealt, y = Lane, fill = Lane)) + geom_col(width = 1) + ggtitle("Median Damage Dealt Per Lane") + common_theme + labs(x = NULL, y = NULL)  + guides(fill = "none")


max4 <- ggplot(m, aes(x = max_DmgDealt, y = Lane, fill = Lane)) + geom_col(width = 1) + ggtitle("Maximum Damage Dealt Per Lane") + common_theme + labs(x = NULL, y = NULL)  + guides(fill = "none")
```


```{r, echo=FALSE}
#mean, median, min, and max of Total Gold:
 m<-MSI_Tbl%>%
  drop_na(TotalGold) %>% 
  group_by(Lane) %>% 
  summarise(avg_TotalGold = mean(TotalGold, na.rm = TRUE),
            median_TotalGold = median(TotalGold, na.rm = TRUE), 
            min_TotalGold = min(TotalGold, na.rm = TRUE),
            max_TotalGold = max(TotalGold, na.rm = TRUE))

mean5 <-ggplot(m, aes(x = avg_TotalGold, y = Lane, fill = Lane)) + geom_col(width = 1) + ggtitle("Average Total Gold Per Lane") + common_theme + labs(x = NULL, y = NULL)  + guides(fill = "none")

med5 <- ggplot(m, aes(x = median_TotalGold, y = Lane, fill = Lane)) + geom_col(width = 1) + ggtitle("Median Total Gold Per Lane") + common_theme + labs(x = NULL, y = NULL)  + guides(fill = "none")

max5 <- ggplot(m, aes(x = max_TotalGold, y = Lane, fill = Lane)) + geom_col(width = 1) + ggtitle("Maximum Total Gold Per Lane")+ common_theme +labs(x = NULL, y = NULL)  + guides(fill = "none")
```



```{r, echo=FALSE, eval=TRUE,  fig.width=10, fig.height=12}
#Combining multiple plots for the averages, medians, and maximums of minions killed, Turret Damage killed, Damage Taken, Damage Dealt, and Total Gold

grid.arrange(mean1, mean2, mean3, mean4, mean5, nrow=5, top = textGrob("Average Damage Player Statistics", gp = gpar(fontsize = 20, fontface = "bold")),left = textGrob("Lane", rot = 90, gp = gpar(fontsize = 16, fontface = "bold")), bottom = textGrob("Average",gp = gpar(fontsize = 16, fontface = "bold")))

grid.arrange(med1, med2, med3, med4, med5, nrow=5, top = textGrob("Median Player Statistics", gp = gpar(fontsize = 20, fontface = "bold")), left = textGrob("Lane", rot = 90, gp = gpar(fontsize = 16, fontface = "bold")), bottom = textGrob("Median",gp = gpar(fontsize = 16, fontface = "bold")))

grid.arrange(max1, max2, max3, max4, max5, nrow=5, top = textGrob("Max Player Statistics", gp = gpar(fontsize = 20, fontface = "bold")), left = textGrob("Lane", rot = 90, gp = gpar(fontsize = 16, fontface = "bold")), bottom = textGrob("Max",gp = gpar(fontsize = 16, fontface = "bold")))


```



**Fun Fact**: ARAM maps are only one lane, almost like a free for all. The map forces you to team fight as soon as the game starts.


# Player Lane Analysis

Kills vs Lane
- Top Lane has the most kills over any other lane
- Middle and Bottom differentiate about 2k kills. 
- Support having the least kills
- None is taken into consideration based on other maps but even then it is not much more.

Why is it that NONE doesn't have the same amount of kills as other lanes? 
- This is due to queue type. queue goes hand in hand with game duration. The longer the game, the more kills. 
- Later on we will see how selection of queue type alone affects this kill distribution. 



```{r, echo=FALSE}
#Lane Data analysis for MSI Kills Column plot
ggplotly(
  ggplot( MSI_Tbl %>%
  select(Lane,kills,SummonerMatchFk) %>%
  drop_na(Lane) %>%
  group_by(Lane) %>%
  count(Lane, wt = kills) %>%
  rename(kills = n),
  aes(x = Lane, y = kills, fill = Lane, text = paste("Count:", after_stat(y))))
  + geom_col() + labs(title= "Kills vs Lane", x = "Lane", y = "Kills"),
  tooltip = "text",
  na.rm = TRUE)
```




# Analyze Gold and Vision Score

**GOLD, GOLD, GOLD!** 
The more money you have the better the items. 
Better items means more damage dealt specially if you are a bottom, Top and Jungle. 


```{r, echo=FALSE}
# 6. Analyze if total gold or dmg dealt increases the chances of winning
# The plot shows that earning more gold and dealing more damage do increase the chances of winning

ggplot(MSI_Tbl %>% drop_na(TotalGold), aes(x = TotalGold, y = DmgDealt, color = Win)) + geom_point(alpha = 0.2) + 
  labs(title="Total Gold vs Damage Dealt by Win/Lose",
       x = "Total Gold",
       y = "Damage Dealt")
  
```



```{r,echo=FALSE}
#10. Find mean, min, max of visionscore and plot mean of visionScore for winning and loosing teams

VS <-MSI_Tbl %>% 
  mutate(Win = ifelse(Win==0, "Lose", "Win")) %>% 
  group_by(Win) %>% 
  summarise(VS_avg = mean(visionScore, na.rm =TRUE),
            VS_min = min(visionScore, na.rm =TRUE), 
            VS_max = max(visionScore, na.rm =TRUE)) %>%
  drop_na(Win)

```



Winning teams have a slight higher **vision score** than losing teams. 

How does vision score correlate to winning?


```{r, echo=FALSE}
#The plot shows higher vision score average will have higher chances of winning

ggplot(VS, aes(x = Win, y = VS_avg, fill = Win)) +
  geom_col() + 
  labs(
   title = "Vision Score: Winning vs Losing",
       x = "Result",
       y = "Vision Score Average"
    )

```


**Interestingly enough, vision score has a big impact on kills and deaths. **


```{r, echo=FALSE}
#11. Analyze if higher visionScore mean more wins

ggplot(MSI_Tbl %>% 
         mutate(Win = ifelse(Win == 1, "Win","Lose")) %>% drop_na(Win), aes(y = kills, x = visionScore, color = Win)) +
  geom_jitter(alpha = 0.3, width = 0.2) + scale_color_manual(values = c("Win" = "blue", "Lose" = "magenta"))+
  labs(title = "Kills by Vision Score",
       x = "Vision Score",  y= "Kills")
         
```



```{r, echo=FALSE}

ggplotly(ggplot(MSI_Tbl %>% drop_na(visionScore), aes(x = visionScore, y = kills, color = Lane)) + geom_smooth(se = FALSE) +
  labs(title = "Vision Score vs Kills by Lane Role",
       x= "Vision Score", y = "Kills"))
```



```{r, echo=FALSE}

ggplot(MSI_Tbl %>% mutate(Win = ifelse(Win == 1, "Win", "Lose")) %>% drop_na(visionScore), aes(x = visionScore, y = deaths, color = Lane)) + geom_smooth(se = FALSE) +
  labs(title = "Vision Score vs Deaths by Lane Role",
       x= "Vision Score", y = "Deaths") + facet_wrap(~Win) + theme_dark()
```


**Vision leads to map control** by providing information on enemy positions, which helps the player and team to make better decisions. 


**Fun Fact**: Wards are placed throughout the map to gain vision. 


# Top 10 Items and Champions

Items are fundamental to scaling a champion. Some items are a non negotiable and are needed, such as boots.


```{r, echo=FALSE}
#Removing NAs from the MSI_Tbl
temp_MSI <- MSI_Tbl%>%
  drop_na(ItemName, ItemName_2, ItemName_3, ItemName_4, ItemName_5, ItemName_6)

#Combining the item name columns into one single column
temp_MSI_Tbl <- MSI_Tbl%>%
  pivot_longer(
    cols = starts_with("ItemName"), # automatically combines columns
    names_to = "Items",             # new column that stores old columns 
    values_to = "ItemNames"         # new column that has the combined columns
     )

#Count the total number of items
new_temp_MSI_Tbl <- temp_MSI_Tbl %>%
  drop_na(ItemNames) %>% 
  group_by(ItemNames) %>% 
  summarise(Total_Items=n()) %>% 
  ungroup()

# #Find most popular items
# new_temp_MSI_Tbl%>% 
#   slice_max(Total_Items, n=10)

"least popular item"

least_items <-new_temp_MSI_Tbl %>% 
  slice_min(Total_Items, n = 10, with_ties = FALSE)

DT::datatable(
  least_items,
  rownames = FALSE,
  options = list( scrollX = TRUE, pageLength = 15, autoWidth = TRUE, columnDefs = list(list(className = "dt-center", targets = "_all"))))

#join temp_MSI_Tbl and new_temp_MSI_Tbl to get the mean and median of items a player holds.
N_MSI_Tbl <- full_join(temp_MSI_Tbl, new_temp_MSI_Tbl, by = join_by(ItemNames)) 

#Mean and median of items a player holds
"Mean and Median of items a player holds"

 ntms <- new_temp_MSI_Tbl %>% 
  drop_na(ItemNames) %>% 
  group_by(ItemNames) %>% 
  summarise(Items_used_avg = mean(Total_Items), 
            Items_used_median = median(Total_Items)) %>% 
  head(n=15)

DT::datatable(
  ntms,
  rownames = FALSE,
  options = list( scrollX = TRUE, pageLength = 15, autoWidth = TRUE, columnDefs = list(list(className = "dt-center", targets = "_all"))))

```




**Top 10 Popular Items**


```{r, echo=FALSE}
#Find the top 10 popular items

Top_Items <- new_temp_MSI_Tbl %>%
  drop_na(ItemNames) %>%
  slice_max(Total_Items, n = 10) 

DT::datatable(
  Top_Items,
  rownames = FALSE,
  options = list(
    scrollX   = TRUE,
    pageLength = 10,
    autoWidth = TRUE,
    columnDefs = list(
      list(className = 'dt-center', targets = "_all") )))
```


```{r, echo=FALSE}
#Plot top 10 popular items 
ggplot(Top_Items, aes(x=reorder(ItemNames, -Total_Items), y = Total_Items, fill = ItemNames, text = paste("Count:", after_stat(y)))) + geom_col() + geom_text(aes(label = Total_Items), 
            hjust = -0.2,           
            size = 3.5, 
            color = "black")+
           labs(
             title ="Top 10 Items", 
             x = "Item Names",
             y = "Total Items") + coord_flip()+ ylim(0, max(Top_Items$Total_Items) * 1.2)

``` 



**Champions** in the data below show that the most popular are from the bottom lane. These are called AD carry's, they tend to be always in meta and are popular among different rank levels.



```{r,echo=FALSE}
#Find the top 10 champions
champs <- SMR_Tbl %>%
  group_by(ChampionName) %>% 
  summarise(num_champs = n())



```


```{r,echo = FALSE}
#Find the top 10 champions

Top_champs <- champs %>% 
  slice_max(num_champs, n = 10)

DT::datatable(
  Top_champs,
  rownames = FALSE,
  options = list(
    scrollX   = TRUE,
    pageLength = 10,
    autoWidth = TRUE,
    columnDefs = list(
      list(className = 'dt-center', targets = "_all") )))
```



```{r,echo=FALSE}
#Plot top 10 champions
ggplotly(ggplot(Top_champs, aes(x = reorder(ChampionName, -num_champs), y = num_champs, fill = ChampionName, text = paste("Count:", after_stat(y)))) + geom_col() +
           labs(title = "Top 10 Champions",
                x = "Champions Name",
                y = "Number of Champions"), tooltip = "text")
```



# More about the players 

It is interesting to see the amount of players that get online to play League of Legends. 

A lot of players fall under Master for Rank, almost double the amount of emerald the second top rank.

- Classic or Summoners rift is the top most played map. Why do we think that is? 

**Fun Fact**: Summoners rift has two queue styles. Normal and Ranked, Normal is a more casual game play and it does not affect your rank, while ranked is very competitive and tracks players progress by promoting or demoting their rank. 



```{r, echo=FALSE}
#each player and the amount of games they play per queue type 

Player_Games <- SMR_Tbl %>% 
  select(SummonerFk,QueueType,RankFk,RankName) %>% 
  group_by(QueueType, SummonerFk, RankName) %>%
  summarise(games = n()) %>% 
  arrange(SummonerFk)

```


```{r, echo=FALSE}
#How many players play in each queue type, a player can play multiple queue types in league of legends. No map restriction.

ggplotly(ggplot(Player_Games %>%
                  drop_na(QueueType),aes(x = QueueType, fill = QueueType, text = paste("Count:", after_stat(count)))) + geom_bar() + labs(title = "Queue Type vs Players", x = "Queue Type", y = "Number of Players"), tooltip = "text", na.rm = TRUE)

```


```{r, echo=FALSE}

rank_levels <- c(
  "Challenger", "Grandmaster", "Master",
  "Diamond", "Emerald", "Platinum",
  "Gold", "Silver", "Bronze", "Iron", "Unranked"
)

rank_data <- Player_Games %>%
  group_by(RankName) %>% 
  distinct(SummonerFk, .keep_all = TRUE) %>% 
  summarise(Players = n()) %>% 
  drop_na(RankName) %>%
  mutate(RankName = factor(RankName, levels = rank_levels))


ggplotly(ggplot(rank_data ,aes(x = RankName, y = Players, fill = RankName, text = paste("Count:", after_stat(y)))) + geom_col() + labs(title = "Rank Name vs Players", x = "Rank Name", y = "Players"), tooltip = "text")

```



# Conclusion 


The data extracted from the League of Legends EU region, shows that teams or players who earn more gold, deal more damage, and have higher vision scores generally have a greater chance of winning. More gold allows players to buy stronger items, which improves their performance in fights. Players can choose the same champion as others, so champions are not tied to a single player.

Game duration is strongly linked to kill counts for both Red and Blue teams. As matches last longer, the total number of kills consistently increases, especially for the winning team. Although different queue types vary in their typical match length, the overall pattern remains the same: longer games result in more kills.
A single player can participate in multiple queue types, and they can switch between them freely with no limitations.

Overall, the data set highlights the importance of strategic decision-making, teamwork, and individual performance in League of Legends. Success is not determined by a single factor, but rather a combination of gold management, damage output, vision control, champion selection, and effective coordination.



