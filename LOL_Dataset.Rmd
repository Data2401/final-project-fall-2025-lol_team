---
title: "LOL_Dataset_Project"
author: "Tamana Yaqoubi, Veronica Alviso"
date: "2025-11-04"
output: html_document
#runtime: shiny
---

## About the dataset 
https://www.kaggle.com/datasets/nathansmallcalder/lol-match-history-and-summoner-data-80k-matches

- The data comes from League of legends (European Region). 
- Shows team analysis and per player analysis providing insight stats in KDA, items, characters "champions', winning, etc 
- The dataset comes from Kaggle.com
##Introduction 
This dataset provides comprehensive match and player information from League of Legends, one of the worldâ€™s most popular multiplayer online battle arena (MOBA) games. It features data from 35,000 matches and over 78,000 player records, covering various in-game aspects such as champion choices, performance metrics, match results, and other gameplay statistics. This dataset consist of 7 tables: MatchStatsTbl, TeamMatchStatsTbl, MatchTbl, RankTble, ChampionTbl, ItemTbl, SummonerTbl, and SummonerMatchTbl. 



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidyr)
library(dplyr)
library(ggplot2)
library(kableExtra)
library(gridExtra)
library(plotly)
library(shiny)
library(here)
library(knitr)
source("R_Data_Prep.R")
#data_dir <- here::here(".")

```

## Read csv files
```{r, echo = FALSE}
'
championTbl <- read_tbl("ChampionTbl")
itemTbl<- read_tbl("ItemTbl")
matchStatsTbl <- read_tbl("MatchStatsTbl")
matchTbl <- read_tbl("MatchTbl")
RankTbl <- read_tbl("RankTbl")
SummonerMatchTbl <- read_tbl("SummonerMatchTbl")
TeamMatchTbl <- read_tbl("TeamMatchTbl")
'
```
---

## View Original datasets
```{r}
head(championTbl) %>% knitr::kable()
head(itemTbl) %>% knitr::kable()
head(matchStatsTbl) %>% knitr::kable()
head(matchTbl) %>% knitr::kable()
head(RankTbl, n = 11) %>% knitr::kable()
head(SummonerMatchTbl) %>% knitr::kable()
head(TeamMatchTbl) %>% knitr::kable()

```

---

## Modified Tables
## Champion Table -VA

The following the data set has basically an NA value named 'No champion'. The data set has been updated so that it only represents actual champions that are playable in League of Legends.

```{r}
championTbl <- championTbl %>% 
  filter(ChampionId > 0)

#championTbl %>% kbl() %>% kable_styling() %>% 
#scroll_box(width = "100%", height = "400px")

#kable(championTbl, align = "r")
```

As you can see, there is no longer a champion ID 0 - No champion. Using the dplyr function filter we successfully removed any irrelevant or not needed rows. 

## MSI Table -TY

What we did is join most of our data sets to have a more efficient data structure. The following data sets were created:
 - match_rank_tbl : This table displays every match in EU region with the following information: Queue type, Rank, Game duration. 
 - MSI_Tbl : This data set will display the players detailed match stats which include kills for both enemy champions and monsters affiliated and include item purchase and summoner spells.
 - SMR_Tbl : This data set displays the players detailed 


```{r, echo =FALSE}
head(match_rank_tbl)
head(TMR_Tble)
head(SMR_Tbl)

```


```{r}
'match_rank_tbl <- full_join(matchTbl,RankTbl,join_by(RankFk == RankId))'
#match_rank_tbl %>% kbl() %>% kable_styling() %>% 
#scroll_box(width = "100%", height = "400px")
```


## TMR Tbl -TY
Created a new table called 'TMR_Tbl' to join Team Match Table and Match Table by MatchFk and MatchId.

```{r, echo = F}
'TMR_Tble <- full_join(TeamMatchTbl, match_rank_tbl, by = join_by(MatchFk == MatchId))'
#TMR_Tble %>% kbl() %>% kable_styling() %>% 
#scroll_box(width = "100%", height = "400px")
```


## SMR tbl -VA

The following table was created in order to join both the summoner match table and a match rank table.
This table displays a smaller depiction 


```{r}
'SMR_Tbl <- full_join(SummonerMatchTbl, championTbl, join_by(ChampionFk == ChampionId))

SMR_Tbl <- full_join(SMR_Tbl, match_rank_tbl, by = join_by(MatchFk == MatchId))'
#SMR_Tbl %>% kbl() %>% kable_styling() %>% 
#scroll_box(width = "100%", height = "400px")
```


## Tamana MSI_tbl and Match_rank_tbl dplyr and plot functions

#MSI_Tbl

MSI_Tbl
```{r}
# MSI_Tbl %>% kbl() %>% kable_styling() %>% 
# scroll_box(width = "100%", height = "400px")
```

1. How many SummonerMatchFk play more than one lane

This code shows how many player plays in more than one lane 
```{r, echo=FALSE}
MSI_Tbl %>%
  group_by(SummonerMatchFk)%>%
  summarise(num_lanes = n_distinct(Lane))%>% #count the unique lanes
  filter(num_lanes > 1)%>%
  summarise(total_players = n())

```


2.Find the Mean, Median, Max, and Min for the following:
- minions killed
- TurretDmg
- DmgTaken
- DmgDealt
- totalGold.


Mean median min and max of minions killed: 
```{r}
m <- MSI_Tbl%>%
  drop_na(MinionsKilled) %>%
  group_by(Lane) %>% 
  summarise(avg_minionsKilled = mean(MinionsKilled, na.rm = T),
            median_minionsKilled = median(MinionsKilled, na.rm = T),
            min_minionsKilled = min(MinionsKilled, na.rm = T),
            max_minionsKilled = max(MinionsKilled, na.rm = T))

mean1 <- ggplot(m, aes(x = avg_minionsKilled, y = Lane, fill = Lane)) + geom_col() + labs(title = "Average Minions Killed Per Lane", x = "Average Minions Killed", y = "Lane")
mean1

med1 <- ggplot(m, aes(x = median_minionsKilled, y = Lane, fill = Lane)) + geom_col() + labs(title = "Median Minions Killed Per Lane", x = "Median Minions Killed", y = "Lane")
med1

max1 <- ggplot(m, aes(x = max_minionsKilled, y = Lane, fill = Lane)) + geom_col() + labs(title = "Max Minions Killed Per Lane", x = "Maximum Minions Killed", y = "Lane")
max1
```



Mean median min and max of Turret Damage killed:
```{r,  echo = F}
m <- MSI_Tbl%>%
  drop_na(TurretDmgDealt) %>% 
  group_by(Lane) %>% 
  summarise(avg_TurretDmgDealt = mean(TurretDmgDealt, na.rm = T),
            median_TurretDmgDealt = median(TurretDmgDealt, na.rm = T),
            min_TurretDmgDealt = min(TurretDmgDealt, na.rm = T), 
            max_TurretDmgDealt = max(TurretDmgDealt, na.rm = T))

mean2 <-ggplot(m, aes(x = avg_TurretDmgDealt, y = Lane, fill = Lane)) + geom_col() + labs(title = "Average Damage Turret Dealt Per Lane", x = "Average Damage Turret Dealt", y = "Lane")
mean2

med2 <- ggplot(m, aes(x = median_TurretDmgDealt, y = Lane, fill = Lane)) + geom_col() + labs(title= "Median Damage Turret Dealt Per Lane", x = "Median Damage Turret Dealt", y = "Lane")
med2

max2 <- ggplot(m, aes(x = max_TurretDmgDealt, y = Lane, fill = Lane)) + geom_col() + labs(title = "Maximum of Damage Turret Dealt", x ="Maximum of Damage Turret Dealt", y = "Lane")
max2
```



mean, median, min, and max of Damage Taken:
```{r, echo = F}
 m <- MSI_Tbl%>%
  drop_na(DmgTaken) %>% 
  group_by(Lane) %>% 
  summarise(avg_DmgTaken = mean(DmgTaken, na.rm = T),
            median_DmgTaken = median(DmgTaken, na.rm = T), 
            min_DmgTaken = min(DmgTaken, na.rm = T),
            max_DmgTaken = max(DmgTaken, na.rm = T))

mean3 <- ggplot(m, aes(x = avg_DmgTaken, y = Lane, fill = Lane)) + geom_col() + labs(title = "Average Damage Taken Per Lane", x = "Average Damage Taken", y = "Lane")
mean3  

med3 <- ggplot(m, aes(x = median_DmgTaken, y = Lane, fill = Lane)) + geom_col() + labs(title = "Median Damage Taken Per Lane", x = "Median Damage Taken", y = "Lane")
med3

max3 <- ggplot(m, aes(x = max_DmgTaken, y = Lane, fill = Lane)) + geom_col() + labs(title = "Maximum Damage Taken Per Lane", x = "Maximum Damage Taken", y = "Lane")
max3
```


mean, median, min, and max of Damage Dealt:
```{r, echo = F}

 m<-MSI_Tbl%>%
  drop_na(DmgDealt) %>% 
  group_by(Lane) %>% 
  summarise(avg_DmgDealt = mean(DmgDealt, na.rm = T),
            median_DmgDealt = median(DmgDealt, na.rm = T), 
            min_DmgDealt = min(DmgDealt, na.rm = T),
            max_DmgDealt = max(DmgDealt, na.rm = T))

mean4 <-ggplot(m, aes(x = avg_DmgDealt, y = Lane, fill = Lane)) + geom_col() + labs(title = "Average Damage Dealt Per Lane", x = "Average Damage Dealt", y = "Lane") 
mean4

med4 <- ggplot(m, aes(x = median_DmgDealt, y = Lane, fill = Lane)) + geom_col() + labs(title = "Median Damage Dealt Per Lane", x = "Median Damage Dealt", y = "Lane")
med4

max4 <- ggplot(m, aes(x = max_DmgDealt, y = Lane, fill = Lane)) + geom_col() + labs(title = "Maximum Damage Dealt Per Lane", x = "Maximum Damage Dealt", y = "Lane")
max4
```


mean, median, min, and max of Total Gold:
```{r, echo = F}
 m<-MSI_Tbl%>%
  drop_na(TotalGold) %>% 
  group_by(Lane) %>% 
  summarise(avg_TotalGold = mean(TotalGold, na.rm = T),
            median_TotalGold = median(TotalGold, na.rm = T), 
            min_TotalGold = min(TotalGold, na.rm = T),
            max_TotalGold = max(TotalGold, na.rm = T))

mean5 <-ggplot(m, aes(x = avg_TotalGold, y = Lane, fill = Lane)) + geom_col() + labs(title = "Average Total Gold Per Lane", x = "Average Total Gold", y = "Lane")
mean5

med5 <- ggplot(m, aes(x = median_TotalGold, y = Lane, fill = Lane)) + geom_col() + labs(title = "Median Total Gold Per Lane", x = "Median Total Gold", y = "Lane")
med5

max5 <- ggplot(m, aes(x = max_TotalGold, y = Lane, fill = Lane)) + geom_col() + labs(title = "Maximum Total Gold Per Lane", x = "Maximum Total Gold", y = "Lane")
max5
```

Combining multiple plots for the averages, medians, and maximums of minions killed, Turret Damage killed, Damage Taken, Damage Dealt, and Total Gold
```{r}
grid.arrange(mean1, mean2, mean3, mean4, mean5, nrow=5) + theme(axis.text = element_text(angle = 45, hjust = 0))
grid.arrange(med1, med2, med3, med4, med5, nrow=5)
grid.arrange(max1, max2, max3, max4, max5, nrow=5)
```

---

3. Create new column (boolean) for indicating win or lose. Filter to win and lose only and create a ggplots.


The plot shows the number of games that wins and loses 
```{r, echo = F} 
MSI_Tbl%>%
  # should i group by queue type?
  mutate(Teams = ifelse(Win==0 , "Lose", "Win"), 
         Teams = factor(Teams, levels = c("Win", "Lose")))%>%
  drop_na(Teams)%>% 
  ggplot(aes(x=Teams, fill=Teams)) + 
  geom_bar() +
  labs(title = "Win vs. Lose", 
       x = "Teams", 
       y = "Number of Games")
```

# Created a new column called SecondLane 
```{r, echo=FALSE}
MSI_Tbl %>% 
   group_by(SummonerMatchFk) %>% 
  filter(n()>1) %>%   
  distinct(SummonerMatchFk, Lane, .keep_all = TRUE) %>% 
  arrange(SummonerMatchFk) %>%   
  filter(n()>1) %>% 
  group_by(SummonerMatchFk) %>% 
  mutate(tally_person = row_number()) %>% 
  filter(tally_person == 2) -> table2

MSI_Tbl %>% 
   group_by(SummonerMatchFk) %>% 
  filter(n()>1) %>%   
  distinct(SummonerMatchFk, Lane, .keep_all = TRUE) %>% 
  arrange(SummonerMatchFk) %>%   
  filter(n()>1) %>% 
  group_by(SummonerMatchFk) %>% 
  mutate(tally_person = row_number()) %>% 
  filter(tally_person == 1) %>%  
  select(SummonerMatchFk, SecondLane = Lane) -> table1

MSI_Tbl_doubles <- full_join(table1, table2, join_by(SummonerMatchFk))
rm(table1)
rm(table2)


MSI_Tbl <- MSI_Tbl %>% 
  group_by(SummonerMatchFk) %>% 
  anti_join(MSI_Tbl_doubles, join_by(SummonerMatchFk)) %>%
  mutate(SecondLane = NA) %>% 
  rbind(MSI_Tbl_doubles) %>% 
  distinct(SummonerMatchFk, .keep_all = TRUE) %>%
  select(-tally_person) %>% 
  arrange(SummonerMatchFk) 

rm(MSI_Tbl_doubles)

```

4. MSI_tbl
filter NAs from item names, 
combine and count total items, 
most popular items, 
least popular items,
Median and mean items a player holds. 

```{r, echo=FALSE}
#Removing NAs from the MSI_Tbl
temp_MSI <- MSI_Tbl%>%
  drop_na(ItemName, ItemName_2, ItemName_3, ItemName_4, ItemName_5, ItemName_6)

#Combining the item name columns into one single column
temp_MSI_Tbl <- MSI_Tbl%>%
  pivot_longer(
    cols = starts_with("ItemName"), # automatically combines columns
    names_to = "Items",             # new column that stores old columns 
    values_to = "ItemNames"         # new column that has the combined columns
     )

#Count the total number of items
new_temp_MSI_Tbl <- temp_MSI_Tbl %>%
  drop_na(new_temp_MSI_Tbl) %>% 
  group_by(ItemNames) %>% 
  summarise(Total_Items=n())

#Find most popular items
new_temp_MSI_Tbl%>% 
  slice_max(Total_Items, n=10)

#least popular item
new_temp_MSI_Tbl %>% 
  slice_min(Total_Items)

#join temp_MSI_Tbl and new_temp_MSI_Tbl to get the mean and median of items a player holds.
N_MSI_Tbl <- full_join(temp_MSI_Tbl, new_temp_MSI_Tbl, by = join_by(ItemNames))


#Mean and median of items a player holds
new_temp_MSI_Tbl %>% 
  drop_na(ItemNames) %>% 
  group_by(ItemNames) %>% 
  summarise(Items_used_avg = mean(Total_Items), 
            Items_used_median = median(Total_Items))
```


5. Plot game duration as the Y value and Queue type as the X value, filter based on RankName.
The plot shows how long the games last in each queue type 
```{r}
match_rank_tbl %>%
  group_by(RankName)%>%
  summarise(Duration= n())

ggplot(match_rank_tbl, aes(x = GameDuration, color= QueueType)) + 
  geom_density() + 
  labs(title = "Game Duration", x = "Game Duration", y = "Density") 
```


```{r}
ggplot(matchStatsTbl, aes(x= kills, color = Lane)) + geom_density() + facet_wrap(~Lane)
```
---


6. Analyze if totalgold or dmgdealt increases the chances of winning
The plot shows that earning more gold and dealing more damage do increase the chances of winning
```{r}
ggplot(MSI_Tbl %>% drop_na(TotalGold), aes(x = TotalGold, y = DmgDealt, color = Win)) + geom_point(alpha = 0.3) + 
  labs(title="Win: Total Gold vs Damage Dealt",
       x = "Total Gold",
       y = "Damage Dealt")
  
```

7. Plot top 10 popular items 
```{r}
Top_Items <- new_temp_MSI_Tbl%>%
  drop_na(ItemNames) %>%
  slice_max(Total_Items, n = 10)

ggplotly(ggplot(Top_Items, aes(x=reorder(ItemNames, -Total_Items), y = Total_Items, fill = ItemNames, text = paste("Count:", after_stat(y)))) + geom_col() + 
           labs(
             title ="Top 10 Items",
             x = "Item Names",
             y = "Total Items"), tooltip = "text") + theme(axis.text.y = element_text(angle = 45, vjust = 0))

``` 

8. Plot top 10 champions
```{r}
champs <- SMR_Tbl %>%
  group_by(ChampionName) %>% 
  summarise(num_champs = n()) %>% 
  drop_na(ChampionName)

```

The plot shows the top 10 champions from left to right
```{r}
Top_champs <- champs %>% 
  slice_max(num_champs, n = 10)

ggplotly(ggplot(Top_champs, aes(x = reorder(ChampionName, -num_champs), y = num_champs, fill = ChampionName, text = paste("Count:", after_stat(y)))) + geom_col() + 
           labs(title = "Top 10 Champions", 
                x = "Champions Name",
                y = "Number of Champions"), tooltip = "text")
```


#Second Lane Data analysis for MSI Kills Column plot
```{r, echo=FALSE}
ggplotly(ggplot( MSI_Tbl %>% 
  select(SecondLane,kills) %>% 
  drop_na(SecondLane) %>% 
  group_by(SecondLane) %>%
  count(SecondLane, wt = kills) %>% 
  rename(kills = n), 
  aes(x = SecondLane, y = kills, fill = SecondLane, text = paste("Count:", after_stat(y))))
  + geom_col(), 
  tooltip = "text", 
  na.rm = TRUE )

```
  

#Lane Data analysis for MSI Kills Column plot
```{r, echo=FALSE}
ggplotly(ggplot( MSI_Tbl %>% 
  select(Lane,kills) %>% 
  drop_na(Lane) %>% 
  group_by(Lane) %>%
  count(Lane, wt = kills) %>% 
  rename(kills = n), 
  aes(x = Lane, y = kills, fill = Lane, text = paste("Count:", after_stat(y))))
  + geom_col() + labs(title= "Kills vs Lane"), 
  tooltip = "text", 
  na.rm = TRUE )

```


#Combine SMR and MSI Table 

10. Find mean, min, max of visionscore and plot mean of visionScore for winning and loosing teams


```{r, echo=FALSE}
VS <-MSI_Tbl %>% 
  mutate(Win = ifelse(Win==0, "Lose", "Win")) %>% 
  group_by(Win) %>% 
  summarise(VS_avg = mean(visionScore, na.rm =T),
            VS_min = min(visionScore, na.rm =T), 
            VS_max = max(visionScore, na.rm =T)) %>%
  drop_na(Win) %>% 
  view()

```
The plot shows higher vision score average will have higher chances of winning
```{r, echo=FALSE}
ggplot(VS, aes(x = Win, y = VS_avg, fill = Win)) +
  geom_col() + 
  labs(
   title = "Vision Score: Winning vs Losing",
       x = "win/lose",
       y = "Vision Score Average"
    )

```


11. Analyze if higher visionScore will have more wins
```{r, echo=FALSE}
ggplot(MSI_Tbl %>% drop_na(visionScore), aes(x = visionScore, color = factor(Win))) + geom_density(alpha = 0.4) + 
  labs(title = "Vision Score: Winning vs Losing Teams",
       x= "Vision Score", y = "Density")
```


12. Compare kills and Lane 
```{r, echo=FALSE}
ggplotly(ggplot(MSI_Tbl %>% 
                  group_by(Lane) %>% 
                  count(Lane, wt = kills) %>% 
                  rename(kills = n), aes(x = Lane, y = kills, fill = Lane, text = paste("Count:", after_stat(y)))) + geom_col() + labs(title = "Kills vs Lane", x = "Lane", y = "kills"), tooltip= "text") 
```


```{r}
MSI_Tbl %>% 
  slice_max(kills) 
```


```{r}

```


## Veronica

1. TMR_tbl create column (boolean) indicating who won. Lets combine TMR with Champion Table 

```{r}


```




```{r}

```




```{r}

```



```{r}

```




```{r}

```




```{r}

```





2. TMR_tbl Filter teams with winning arams, classics based on rank. Bar graph & scatter plot x = rank, y = # of wins, color by queue types, density. face wrap

Let us look at all winning teams from each map type.
```{r}
#source(here::here("WinningTeams","app.R"))
#shinyApp(ui, server) 
#head(Team_Winner_Tbl, n = 10) 
```


3. TMR_tbl Filter winning teams, most used champion in red team and blue team 

```{r}



```


4. TMR_tbl find the mean, median, max and min (all kills) only for classic queue types

```{r}

TMR_Tble %>%
  filter(QueueType == "CLASSIC") %>% 
  summarise(
    Total_Mean_Kills = mean(RedKills + BlueKills, na.rm = TRUE),
    Total_Medium_Kills = median(RedKills + BlueKills, na.rm = TRUE),
    Max_Kills = max(RedKills + BlueKills, na.rm = TRUE),
    Red_Mean = mean(RedKills, na.rm = TRUE),
    Blue_Mean = mean(BlueKills, na.rm = TRUE),
    Red_Median = median(RedKills, na.rm = TRUE),
    Blue_Median = median(BlueKills, na.rm = TRUE),
    Red_Max = max(RedKills, na.rm = TRUE),
    Blue_Min = max(BlueKills, na.rm = TRUE)
    )

```


Team winner table mean min max of the for Both teams : Kills, Baron, Rift Herald, Dragon, Towers

```{r}
  
Team_Winner_Stats <-Team_Winner_Tbl %>%
  filter(Side %in% c("Red","Blue")) %>%
  filter(QueueType %in% c("CLASSIC", "ARAM","SWIFTPLAY","ULTBOOK")) %>% 
  group_by(Side, QueueType) %>% 
  summarise(MeanKills = mean(Kills, na.rm = TRUE),
            MinKills = min(Kills, na.rm = TRUE),
            MaxKills = max(Kills, na.rm = TRUE),
            MeanBaron = mean(BaronKills, na.rm = TRUE),
            MinBaron = min(BaronKills, na.rm = TRUE),
            MaxBaron = max(BaronKills, na.rm = TRUE),
            MeanRiftHeraldKills = mean(RiftHeraldKills, na.rm = TRUE),
            MinRiftHeraldKills = min(RiftHeraldKills, na.rm = TRUE),
            MaxRiftHeraldKills = max(RiftHeraldKills, na.rm = TRUE),
            MeanDragonKills = mean(DragonKills, na.rm = TRUE),
            MinDragonKills = min(DragonKills, na.rm = TRUE),
            MaxDragonKills = max(DragonKills, na.rm = TRUE),
            MeanTowerKills = mean(TowerKills, na.rm = TRUE),
            MinTowerKills = min(TowerKills, na.rm = TRUE),
            MaxTowerKills = max(TowerKills, na.rm = TRUE))

view(Team_Winner_Stats)
```


# Bar plot 
```{r}
ggplotly(ggplot(Team_Winner_Stats, aes(x = QueueType, y = MeanKills, fill = Side,text = paste("Count:", after_stat(y)))) + geom_col() + facet_wrap(~Side), tooltip = "text")
```

```{r}
ggplotly(ggplot(Team_Winner_Stats %>% 
                  filter(QueueType!= "ARAM"), aes(x = QueueType, y = MeanBaron, fill = Side,text = paste("Count:", after_stat(y)))) + geom_col() + facet_wrap(~Side), tooltip = "text")
```

```{r}
ggplotly(ggplot(Team_Winner_Stats %>% 
                  filter(QueueType!= "ARAM"), aes(x = QueueType, y = MeanRiftHeraldKills, fill = Side,text = paste("Count:", after_stat(y)))) + geom_col() + facet_wrap(~Side), tooltip = "text")
```


7.each player and the amount of games they play per queue type 

```{r}
Player_Games <- SMR_Tbl %>% 
  select(SummonerFk,QueueType,RankFk,RankName) %>% 
  group_by(QueueType, SummonerFk, RankName) %>%
  summarise(games = n()) %>% 
  arrange(SummonerFk)

```

How many players play in each queue type, a player can play multiple queue types in league of legends. No map restriction.
```{r}

ggplotly(ggplot(Player_Games,aes(x = QueueType, fill = QueueType, text = paste("Count:", after_stat(count)))) + geom_bar(), tooltip = "text", na.rm = TRUE)

```

```{r}
Player_Games %>%
  group_by(RankName) %>% 
  distinct(SummonerFk,.keep_all = TRUE) %>% 
  summarise(n=n()) %>% 
  drop_na(RankName) %>% 
  rename(Players = n)
```

What rank players fall in in this data set. 

```{r}
ggplotly(ggplot(Player_Games %>%
  group_by(RankName) %>% 
  distinct(SummonerFk,.keep_all = TRUE) %>% 
  summarise(n=n()) %>% 
  drop_na(RankName) %>% 
  rename(Players = n),aes(x = RankName, y = Players, fill = RankName, text = paste("Count:", after_stat(y)))) + geom_col(), tooltip = "text", na.rm = TRUE)

```

Fun fact: 
```{r}

```

